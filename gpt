ä½ çš„éœ€æ±‚å·²ç»å¾ˆæ˜ç¡®äº†ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ª å¤–éƒ¨ç³»ç»Ÿè°ƒç”¨å®¡è®¡ & å¯è§‚æµ‹æ€§ æ¨¡å—ï¼Œæ ¸å¿ƒè¦è§£å†³ä¸‰ä¸ªé—®é¢˜ï¼š

è¯·æ±‚å®¡è®¡ï¼ˆæŠ¥æ–‡ã€å…³é”®å…ƒä¿¡æ¯ã€è€—æ—¶ï¼‰

å¯è§‚æµ‹æ€§æŒ‡æ ‡ï¼ˆæˆåŠŸ/å¤±è´¥æ¬¡æ•°ã€çŠ¶æ€ç åˆ†å¸ƒã€è€—æ—¶åˆ†å¸ƒï¼‰

å“åº”ä½“çš„å¯é‡å¤è¯»å–ï¼ˆå› ä¸ºå“åº”æµé»˜è®¤åªèƒ½æ¶ˆè´¹ä¸€æ¬¡ï¼‰

ä¸‹é¢æˆ‘å¸®ä½ æ‹†ä¸€ä¸‹ï¼š

ğŸ”‘ éœ€è¦å®ç°çš„æ‹¦æˆªå™¨
1. è¯·æ±‚/å“åº”å®¡è®¡æ‹¦æˆªå™¨

åŠŸèƒ½ï¼š

è®°å½•è¯·æ±‚ URIã€æ–¹æ³•ã€Headersï¼ˆæ³¨æ„è„±æ•ï¼‰ã€è¯·æ±‚ä½“ï¼ˆå¤§å° & å†…å®¹ï¼Œæ³¨æ„åªåœ¨å¯æ§å¤§å°ä¸‹å­˜å‚¨ï¼‰ã€TraceIdã€‚

è®°å½•å“åº”çŠ¶æ€ç ã€è€—æ—¶ã€å“åº”ä½“ï¼ˆå¯é€‰ï¼Œéœ€æ³¨æ„å¤§å° & æ•æ„Ÿä¿¡æ¯ï¼‰ã€‚

è¾“å‡ºåˆ° å®¡è®¡æ—¥å¿—ï¼ˆé€šå¸¸å•ç‹¬çš„ loggerï¼Œè½ç›˜/è½åº“ï¼‰ã€‚

å®ç°ï¼š

@Component
public class AuditLoggingInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        long start = System.currentTimeMillis();

        // è¯·æ±‚æ—¥å¿—
        log.info("[AUDIT] Request: method={}, uri={}, headers={}, body={}",
                 request.getMethod(), request.getURI(), sanitizeHeaders(request.getHeaders()), tryToRead(body));

        ClientHttpResponse response = execution.execute(request, body);
        // åŒ…è£…å“åº”ï¼Œè§£å†³ä¸å¯é‡å¤è¯»é—®é¢˜
        ClientHttpResponse buffered = new BufferingClientHttpResponseWrapper(response);

        long elapsed = System.currentTimeMillis() - start;
        String responseBody = StreamUtils.copyToString(buffered.getBody(), StandardCharsets.UTF_8);

        log.info("[AUDIT] Response: uri={}, status={}, elapsed={}ms, body={}",
                 request.getURI(), buffered.getStatusCode(), elapsed, truncate(responseBody));

        return buffered; // è¿”å›åŒ…è£…åçš„å“åº”
    }
}

2. å¼‚å¸¸æ‹¦æˆªå™¨

åŠŸèƒ½ï¼š

æ•æ‰å¤–éƒ¨ç³»ç»Ÿè¿æ¥å¤±è´¥ã€è¶…æ—¶ç­‰å¼‚å¸¸ï¼›

è½¬æ¢ä¸ºç»Ÿä¸€çš„ä¸šåŠ¡å¼‚å¸¸ï¼›

è®°å½•å¼‚å¸¸ç›¸å…³çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚

3. æŒ‡æ ‡é‡‡é›†æ‹¦æˆªå™¨

åŠŸèƒ½ï¼š

ä½¿ç”¨ Micrometer è®°å½•è°ƒç”¨æ¬¡æ•°ã€é”™è¯¯æ¬¡æ•°ã€è€—æ—¶ç›´æ–¹å›¾ï¼›

æŒ‰ç…§ å¤–éƒ¨ç³»ç»Ÿå + æ¥å£è·¯å¾„ + çŠ¶æ€ç  ä½œä¸ºæ ‡ç­¾ã€‚

å®ç°ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰ï¼š

@Component
@RequiredArgsConstructor
public class MetricsInterceptor implements ClientHttpRequestInterceptor {

    private final MeterRegistry meterRegistry;

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        long start = System.nanoTime();
        try {
            ClientHttpResponse response = execution.execute(request, body);
            record(request, response.getStatusCode().value(), start);
            return response;
        } catch (IOException e) {
            record(request, 500, start);
            throw e;
        }
    }

    private void record(HttpRequest request, int status, long start) {
        Timer.builder("external.http.requests")
             .tags("system", resolveSystemName(request.getURI()),
                   "method", request.getMethod().name(),
                   "status", String.valueOf(status))
             .register(meterRegistry)
             .record(System.nanoTime() - start, TimeUnit.NANOSECONDS);
    }
}

âš ï¸ å“åº”ä½“ä¸å¯é‡å¤è¯»é—®é¢˜
é—®é¢˜ï¼š

Spring ClientHttpResponse çš„ getBody() æ˜¯ä¸€ä¸ª æµï¼Œé»˜è®¤åªèƒ½è¯»ä¸€æ¬¡ã€‚

å¦‚æœä½ åœ¨æ‹¦æˆªå™¨é‡Œå…ˆè¯»ä¸€æ¬¡ bodyï¼Œä¸šåŠ¡å±‚å†è°ƒç”¨ .body(Class<T>) å°±ä¼šæŠ¥ç©ºã€‚

è§£å†³æ–¹æ¡ˆï¼š

ç”¨ Spring æä¾›çš„ BufferingClientHttpResponseWrapper åŒ…è£…å“åº”ï¼Œç¼“å­˜å­—èŠ‚æ•°ç»„åå†è¿”å›ã€‚
è¿™æ ·ä½ æ—¢èƒ½åœ¨æ‹¦æˆªå™¨é‡Œè¯»å– bodyï¼Œåˆèƒ½è®©ä¸šåŠ¡å±‚æ­£å¸¸æ¶ˆè´¹ã€‚

ClientHttpResponse response = execution.execute(request, body);
ClientHttpResponse buffered = new BufferingClientHttpResponseWrapper(response);


ä½†æ˜¯ï¼š

å¤§å“åº”ä½“ï¼ˆæ–‡ä»¶ä¸‹è½½ã€å¤§ JSONï¼‰å¯èƒ½å å†…å­˜ â†’ éœ€è¦åš å¤§å°é™åˆ¶ï¼ˆæ¯”å¦‚è¶…è¿‡ 1MB åªè®°å½•å‰ N KBï¼‰ã€‚

å“åº”ä½“æ•æ„Ÿå­—æ®µï¼ˆtokenã€èº«ä»½è¯å·ï¼‰éœ€è¦ è„±æ•ã€‚

âœ… æœ€ä½³å®è·µæ€»ç»“

ä½ è‡³å°‘éœ€è¦ ä¸‰ä¸ªæ‹¦æˆªå™¨ï¼š

å®¡è®¡æ‹¦æˆªå™¨ï¼ˆè¯·æ±‚ + å“åº”æ—¥å¿—ï¼Œå¸¦è€—æ—¶ï¼‰

å¼‚å¸¸æ‹¦æˆªå™¨ï¼ˆå¼‚å¸¸ç»Ÿä¸€åŒ…è£… + æ—¥å¿—ï¼‰

æŒ‡æ ‡æ‹¦æˆªå™¨ï¼ˆMicrometer è®°å½•è¯·æ±‚æ¬¡æ•°ã€å“åº”çŠ¶æ€åˆ†å¸ƒã€è€—æ—¶ï¼‰

å¦å¤–è¦æ³¨æ„ï¼š

å“åº”ä½“é‡å¤è¯»é—®é¢˜å¿…é¡»è€ƒè™‘ï¼Œç”¨ BufferingClientHttpResponseWrapperã€‚

å¤§æŠ¥æ–‡è¦æˆªæ–­/æ‘˜è¦å­˜å‚¨ï¼Œä¸ç„¶å†…å­˜å‹åŠ›å¤§ã€‚

æ•æ„Ÿä¿¡æ¯è¦è„±æ•ã€‚

æ—¥å¿—å’ŒæŒ‡æ ‡åˆ†å¼€å¤„ç†ï¼šæ—¥å¿—å­˜å‚¨å®¡è®¡ç”¨ï¼ŒæŒ‡æ ‡ç»™ Prometheus/å¯è§‚æµ‹å¹³å°ã€‚

è¦ä¸è¦æˆ‘å¸®ä½ è®¾è®¡ä¸€ä¸ª å®Œæ•´çš„æ‹¦æˆªå™¨é“¾ï¼ˆAudit + Metrics + Exceptionï¼‰ï¼Œå¹¶ç»“åˆ RestClientFactory æ¼”ç¤ºå¦‚ä½•ä¸€æ¬¡æ€§æŒ‚è½½åˆ°æ‰€æœ‰å¤–éƒ¨ç³»ç»Ÿ client ä¸Šï¼Ÿ

æ‚¨è¯´ï¼š
- è®¾è®¡ä¸€ä¸ª å®Œæ•´çš„æ‹¦æˆªå™¨é“¾ï¼ˆAudit + Metrics + Exceptionï¼‰ï¼Œå¹¶ç»“åˆ RestClientFactory æ¼”ç¤ºå¦‚ä½•ä¸€æ¬¡æ€§æŒ‚è½½åˆ°æ‰€æœ‰å¤–éƒ¨ç³»ç»Ÿ client ä¸Š
- å®ç°å¯¹å¤§å“åº”ä½“ï¼ˆæ–‡ä»¶ä¸‹è½½ã€å¤§ JSONï¼‰çš„ å¤§å°é™åˆ¶
- æ”¯æŒå¯¹å“åº”ä½“æ•æ„Ÿå­—æ®µï¼ˆtokenã€èº«ä»½è¯å·ï¼‰çš„ è„±æ•
ChatGPT è¯´ï¼š

å¥½ğŸ‘Œï¼Œæˆ‘æ¥å¸®ä½ è®¾è®¡ä¸€ä¸ª å®Œæ•´çš„æ‹¦æˆªå™¨é“¾ï¼ˆAudit + Metrics + Exceptionï¼‰ï¼ŒåŒæ—¶æ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š

ç»Ÿä¸€æŒ‚è½½ï¼šæ‰€æœ‰å¤–éƒ¨ç³»ç»Ÿçš„ RestClient éƒ½èƒ½è‡ªåŠ¨å¸¦ä¸Šæ‹¦æˆªå™¨é“¾ï¼›

å¤§å“åº”ä½“é™åˆ¶ï¼šè¶…è¿‡é…ç½®å¤§å°åªæˆªå–å‰ N KBï¼›

å“åº”ä½“æ•æ„Ÿå­—æ®µè„±æ•ï¼šæ¯”å¦‚ tokenã€èº«ä»½è¯å·ç­‰æ›¿æ¢æˆ ****ï¼›

åˆ†å·¥æ¸…æ™°ï¼š

AuditInterceptorï¼šè¯·æ±‚/å“åº”æ—¥å¿—ã€è€—æ—¶ã€è„±æ•ã€å¤§å°é™åˆ¶

MetricsInterceptorï¼šæŒ‡æ ‡é‡‡é›†ï¼ˆæˆåŠŸç‡ã€è€—æ—¶ã€çŠ¶æ€åˆ†å¸ƒï¼‰

ExceptionInterceptorï¼šå¼‚å¸¸æ•è·ã€ç»Ÿä¸€åŒ…è£…

ğŸ—ï¸ æ‹¦æˆªå™¨å®ç°
ğŸ”¹ AuditInterceptor
@Slf4j
@Component
public class AuditInterceptor implements ClientHttpRequestInterceptor {

    private static final int MAX_BODY_LOG_SIZE = 1024 * 4; // 4KB

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        long start = System.currentTimeMillis();

        // è¯·æ±‚æ—¥å¿—
        log.info("[AUDIT] Request: method={}, uri={}, headers={}, body={}",
                 request.getMethod(), request.getURI(),
                 sanitizeHeaders(request.getHeaders()), truncateAndMask(body));

        // æ‰§è¡Œè¯·æ±‚å¹¶åŒ…è£…å“åº”ï¼Œé¿å…å“åº”ä½“ä¸å¯é‡å¤è¯»
        ClientHttpResponse response = execution.execute(request, body);
        ClientHttpResponse buffered = new BufferingClientHttpResponseWrapper(response);

        long elapsed = System.currentTimeMillis() - start;

        String responseBody = StreamUtils.copyToString(buffered.getBody(), StandardCharsets.UTF_8);
        log.info("[AUDIT] Response: uri={}, status={}, elapsed={}ms, body={}",
                 request.getURI(), buffered.getStatusCode(), elapsed,
                 truncateAndMask(responseBody));

        return buffered;
    }

    private String truncateAndMask(byte[] body) {
        return truncateAndMask(new String(body, StandardCharsets.UTF_8));
    }

    private String truncateAndMask(String raw) {
        if (raw == null) return "";
        String masked = maskSensitiveFields(raw);
        if (masked.length() > MAX_BODY_LOG_SIZE) {
            return masked.substring(0, MAX_BODY_LOG_SIZE) + "...(truncated)";
        }
        return masked;
    }

    private String maskSensitiveFields(String raw) {
        // ç®€å•ç¤ºä¾‹ï¼štoken å’Œèº«ä»½è¯å·è„±æ•
        String masked = raw.replaceAll("(?i)\"token\"\\s*:\\s*\"(.*?)\"", "\"token\":\"****\"");
        masked = masked.replaceAll("\\d{15,18}[0-9Xx]", "****ID****");
        return masked;
    }

    private HttpHeaders sanitizeHeaders(HttpHeaders headers) {
        HttpHeaders safe = new HttpHeaders();
        headers.forEach((k, v) -> {
            if (k.equalsIgnoreCase("Authorization") || k.equalsIgnoreCase("Cookie")) {
                safe.put(k, List.of("****"));
            } else {
                safe.put(k, v);
            }
        });
        return safe;
    }
}

ğŸ”¹ MetricsInterceptor
@Component
@RequiredArgsConstructor
public class MetricsInterceptor implements ClientHttpRequestInterceptor {

    private final MeterRegistry meterRegistry;

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        long start = System.nanoTime();
        try {
            ClientHttpResponse response = execution.execute(request, body);
            record(request, response.getStatusCode().value(), start);
            return response;
        } catch (IOException e) {
            record(request, 500, start);
            throw e;
        }
    }

    private void record(HttpRequest request, int status, long start) {
        Timer.builder("external.http.requests")
             .tags("system", resolveSystemName(request.getURI()),
                   "method", request.getMethod().name(),
                   "status", String.valueOf(status))
             .register(meterRegistry)
             .record(System.nanoTime() - start, TimeUnit.NANOSECONDS);
    }

    private String resolveSystemName(URI uri) {
        // æ ¹æ®åŸŸå/host æ˜ å°„å¤–éƒ¨ç³»ç»Ÿå
        return uri.getHost();
    }
}

ğŸ”¹ ExceptionInterceptor
@Slf4j
@Component
public class ExceptionInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        try {
            return execution.execute(request, body);
        } catch (IOException ex) {
            log.error("[EXTERNAL-ERROR] Request failed: method={}, uri={}, msg={}",
                      request.getMethod(), request.getURI(), ex.getMessage(), ex);
            throw new ExternalSystemException("å¤–éƒ¨ç³»ç»Ÿè°ƒç”¨å¤±è´¥", ex);
        }
    }
}

ğŸ”§ RestClientFactory ä¸€æ¬¡æ€§æŒ‚è½½æ‹¦æˆªå™¨é“¾
@Component
@RequiredArgsConstructor
public class RestClientFactory {

    private final AuditInterceptor auditInterceptor;
    private final MetricsInterceptor metricsInterceptor;
    private final ExceptionInterceptor exceptionInterceptor;

    public RestClient create(ExternalSystemProperties props,
                             List<ClientHttpRequestInterceptor> customInterceptors) {

        List<ClientHttpRequestInterceptor> allInterceptors = new ArrayList<>();
        allInterceptors.add(auditInterceptor);
        allInterceptors.add(metricsInterceptor);
        allInterceptors.add(exceptionInterceptor);
        if (customInterceptors != null) {
            allInterceptors.addAll(customInterceptors);
        }

        return RestClient.builder()
                .baseUrl(props.getBaseUrl())
                .requestInterceptor(allInterceptors)
                .build();
    }
}

âœ… ä½¿ç”¨æ–¹å¼ï¼ˆä¸šåŠ¡å±‚è°ƒç”¨ï¼‰
@Component
@RequiredArgsConstructor
public class CustomerGatewayImpl implements CustomerGateway {

    private final RestClientFactory factory;
    private final ExternalSystemProperties props;

    private RestClient client;

    @PostConstruct
    void init() {
        this.client = factory.create(props.getCustomerSystem(),
            List.of(new AuthenticationInterceptor(props.getCustomerSystem().getApiKey()))
        );
    }

    @Override
    public CustomerInfo getCustomerById(String customerId) {
        return client.get()
                .uri("/api/customers/{id}", customerId)
                .retrieve()
                .body(CustomerInfo.class);
    }
}

ğŸ¯ æ•ˆæœæ€»ç»“

ç»Ÿä¸€æ‹¦æˆªå™¨é“¾ï¼šæ‰€æœ‰å¤–éƒ¨ç³»ç»Ÿ client é»˜è®¤æŒ‚è½½ Audit + Metrics + Exceptionï¼›

è¯·æ±‚/å“åº”å®¡è®¡ï¼šæŠ¥æ–‡ã€çŠ¶æ€ã€è€—æ—¶å¯è¿½è¸ªï¼›

å¤§å“åº”ä½“æ§åˆ¶ï¼šæ—¥å¿—åªä¿ç•™å‰ N KBï¼Œé¿å…å†…å­˜é—®é¢˜ï¼›

æ•æ„Ÿå­—æ®µè„±æ•ï¼štoken/èº«ä»½è¯å·ä¸è½åº“ï¼›

æŒ‡æ ‡é‡‡é›†ï¼šPrometheus / Grafana å¯ç›´æ¥ç›‘æ§å¤–éƒ¨è°ƒç”¨æƒ…å†µï¼›

å¼‚å¸¸ç»Ÿä¸€å¤„ç†ï¼šå¤–éƒ¨ç³»ç»Ÿå¼‚å¸¸åŒ…è£…æˆä¸šåŠ¡å¯è¯†åˆ«å¼‚å¸¸ã€‚

è¦ä¸è¦æˆ‘å†å¸®ä½ è®¾è®¡ä¸€ä¸ª é…ç½®åŒ–å¼€å…³ï¼ˆæ¯”å¦‚åªå¯¹æŸäº›ç³»ç»Ÿå¼€å¯å“åº”ä½“è®°å½•ï¼Œæˆ–è€…åŠ¨æ€è°ƒæ•´æˆªæ–­å¤§å°ï¼‰ï¼Œè¿™æ ·å¯ä»¥é¿å…å¯¹å¤§æ–‡ä»¶ä¸‹è½½æ¥å£æ‰“æ»¡æ—¥å¿—ï¼Ÿ

æ‚¨è¯´ï¼š
å†è®¾è®¡ä¸€ä¸ªé…ç½®è¯å¼€å…³ï¼ˆæ¯”å¦‚åªå¯¹æŸäº›ç³»ç»Ÿå¼€å¯å“åº”ä½“è®°å½•ï¼Œæˆ–è€…åŠ¨æ€è°ƒæ•´æˆªæ–­å¤§å°ï¼‰ï¼Œè¿™æ ·å¯ä»¥é¿å…å¯¹å¤§æ–‡ä»¶ä¸‹è½½æ¥å£æ‰“æ»¡æ—¥å¿—
- æ”¹ä¸ºä½¿ç”¨ BufferingClientHttpRequestFactory æ¥è§£å†³ä¸å¯é‡å¤çš„é—®é¢˜
- æ¯ä¸ªå¤–éƒ¨ç³»ç»Ÿä¼šç»™æˆ‘ä»¬æä¾›å¤šä¸ªæ¥å£ï¼ˆå¯¹åº”ä¸åŒçš„è®¿é—®åœ°å€å’Œè¯·æ±‚æ–¹æ³•ä»¥åŠè¿”å›ä½“ï¼‰ï¼Œå¦‚æœæ¯ä¸ªéƒ½åœ¨ä»£ç ä¸­å¦‚è¿™é‡Œçš„getCustomerByIdä¸€æ ·ï¼Œå†™æ­»getæ–¹å¼ï¼Œuriåœ°å€ï¼ˆ/api/customers/{id}ï¼‰ï¼ŒCustomerInfo.classï¼Œé‚£ä¹ˆé…ç½®å°±æ•£è½åœ¨ä»£ç ä¸­äº†ï¼Œæœ‰æ²¡æœ‰å…¶ä»–æ›´ä¼˜é›…çš„è§£å†³æ–¹æ¡ˆ
@Override
    public CustomerInfo getCustomerById(String customerId) {
        return client.get()
                .uri("/api/customers/{id}", customerId)
                .retrieve()
                .body(CustomerInfo.class);
    }
ChatGPT è¯´ï¼š

å¥½é—®é¢˜ ğŸ‘ ä½ ç°åœ¨è€ƒè™‘çš„æ˜¯ä¸‰ä¸ªç»´åº¦ï¼š

é…ç½®åŒ–å¼€å…³ï¼šæ—¥å¿—æ˜¯å¦è®°å½•å“åº”ä½“ã€æˆªæ–­å¤§å°ç­‰ â†’ ä¸åŒå¤–éƒ¨ç³»ç»Ÿå¯ä»¥å·®å¼‚åŒ–ï¼›

å“åº”ä½“ä¸å¯é‡å¤è¯»é—®é¢˜ï¼šæ‹¦æˆªå™¨é‡Œè¯» body â†’ æ¨èç”¨ BufferingClientHttpRequestFactoryï¼›

æ¥å£é…ç½®æ•£è½é—®é¢˜ï¼šé¿å… getCustomerById() è¿™ç§å†™æ­» URI + HTTP æ–¹æ³• + è¿”å›ç±»å‹ â†’ æ›´ä¼˜é›…çš„ DSL/é…ç½®é©±åŠ¨æ–¹å¼ã€‚

æˆ‘åˆ†å¼€ç»™ä½ æ¢³ç†ï¼š

1. é…ç½®åŒ–å¼€å…³

å¯ä»¥åœ¨ application.yml é…ç½®æ¯ä¸ªå¤–éƒ¨ç³»ç»Ÿçš„è°ƒç”¨ç­–ç•¥ï¼Œä¾‹å¦‚ï¼š

external-systems:
  customer:
    base-url: "https://customer-system/api"
    audit:
      log-response-body: true
      max-body-size: 4096
  order:
    base-url: "https://order-system/api"
    audit:
      log-response-body: false   # æ–‡ä»¶ä¸‹è½½æ¥å£ï¼Œä¸è®°å½•body
      max-body-size: 1024


å¯¹åº”çš„é…ç½®ç±»ï¼š

@ConfigurationProperties(prefix = "external-systems")
@Data
public class ExternalSystemsProperties {
    private Map<String, ExternalSystemConfig> systems;

    @Data
    public static class ExternalSystemConfig {
        private String baseUrl;
        private AuditConfig audit = new AuditConfig();
    }

    @Data
    public static class AuditConfig {
        private boolean logResponseBody = true;
        private int maxBodySize = 4096; // é»˜è®¤ 4KB
    }
}


åœ¨ AuditInterceptor é‡ŒåŠ¨æ€è¯»å–ï¼š

@Component
@RequiredArgsConstructor
public class AuditInterceptor implements ClientHttpRequestInterceptor {

    private final ExternalSystemsProperties props;

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        String system = resolveSystemName(request.getURI());
        ExternalSystemsProperties.AuditConfig auditCfg =
            props.getSystems().getOrDefault(system, new ExternalSystemsProperties.ExternalSystemConfig()).getAudit();

        ClientHttpResponse response = execution.execute(request, body);
        ClientHttpResponse buffered = new BufferingClientHttpResponseWrapper(response);

        if (auditCfg.isLogResponseBody()) {
            String responseBody = StreamUtils.copyToString(buffered.getBody(), StandardCharsets.UTF_8);
            String loggedBody = truncateAndMask(responseBody, auditCfg.getMaxBodySize());
            log.info("[AUDIT] system={}, uri={}, status={}, body={}", system, request.getURI(), buffered.getStatusCode(), loggedBody);
        }

        return buffered;
    }

    private String truncateAndMask(String raw, int maxSize) {
        if (raw == null) return "";
        String masked = maskSensitiveFields(raw);
        if (masked.length() > maxSize) {
            return masked.substring(0, maxSize) + "...(truncated)";
        }
        return masked;
    }
}


è¿™æ ·å°±èƒ½æŒ‰ç³»ç»Ÿå·®å¼‚åŒ–å¼€å…³æ—¥å¿—å’Œæˆªæ–­å¤§å°ã€‚

2. ä½¿ç”¨ BufferingClientHttpRequestFactory

ç›¸æ¯”æ‰‹åŠ¨ç”¨ BufferingClientHttpResponseWrapperï¼Œæ¨èç›´æ¥åœ¨ RestClient åˆ›å»ºæ—¶å…¨å±€å¯ç”¨ï¼š

@Bean
public RestClient.Builder restClientBuilder(List<ClientHttpRequestInterceptor> interceptors) {
    return RestClient.builder()
        .requestFactory(new BufferingClientHttpRequestFactory(new SimpleClientHttpRequestFactory()))
        .requestInterceptor(interceptors);
}


è¿™æ ·æ‰€æœ‰è¯·æ±‚è¿”å›çš„å“åº”ä½“éƒ½èƒ½é‡å¤è¯»å–ï¼Œæ‹¦æˆªå™¨é‡Œè¯» body ä¸ä¼šå½±å“ä¸šåŠ¡ã€‚

âš ï¸ æ³¨æ„ï¼š

æ–‡ä»¶æµä¸‹è½½ç±»æ¥å£æœ€å¥½ä¸è¦ç”¨è¿™ä¸ª factoryï¼Œå¦åˆ™ä¼šç¼“å­˜å¤§æ–‡ä»¶åˆ°å†…å­˜ï¼›å¯ä»¥é€šè¿‡é…ç½®å¯¹æŸäº›ç³»ç»Ÿå…³é—­ body è®°å½•ã€‚

3. é¿å…æ¥å£è°ƒç”¨é…ç½®æ•£è½

ç›®å‰çš„é—®é¢˜æ˜¯ï¼š

@Override
public CustomerInfo getCustomerById(String customerId) {
    return client.get()
            .uri("/api/customers/{id}", customerId)
            .retrieve()
            .body(CustomerInfo.class);
}


â†’ æ–¹æ³•ç­¾åã€HTTP æ–¹æ³•ã€URIã€è¿”å›ç±»å‹å…¨å†™æ­»åœ¨ä»£ç ã€‚
å¦‚æœå¤–éƒ¨ç³»ç»Ÿå¾ˆå¤šï¼Œå°±ä¼šåˆ°å¤„æ˜¯ client.get().uri("/xx")...ã€‚

æ›´ä¼˜é›…çš„æ–¹å¼ï¼š
æ–¹æ¡ˆ A: é…ç½®é©±åŠ¨ + é€šç”¨è°ƒç”¨å™¨

åœ¨é…ç½®æ–‡ä»¶é‡Œå®šä¹‰æ¥å£æè¿°ï¼š

external-systems:
  customer:
    base-url: "https://customer-system/api"
    apis:
      get-customer:
        method: GET
        uri: "/customers/{id}"
        response-type: com.example.CustomerInfo
      create-customer:
        method: POST
        uri: "/customers"
        response-type: com.example.CustomerInfo


å°è£…ä¸€ä¸ª DynamicApiInvokerï¼š

@Component
@RequiredArgsConstructor
public class DynamicApiInvoker {

    private final RestClientFactory factory;
    private final ExternalSystemsProperties props;

    public <T> T invoke(String system, String apiKey, Map<String, Object> uriVars, Object body, Class<T> responseType) {
        ExternalSystemsProperties.ExternalSystemConfig cfg = props.getSystems().get(system);
        ApiConfig apiCfg = cfg.getApis().get(apiKey);

        RestClient client = factory.create(cfg, null);

        RestClient.RequestSpec request = switch (apiCfg.getMethod().toUpperCase()) {
            case "GET" -> client.get().uri(apiCfg.getUri(), uriVars);
            case "POST" -> client.post().uri(apiCfg.getUri(), uriVars).body(body);
            case "PUT" -> client.put().uri(apiCfg.getUri(), uriVars).body(body);
            default -> throw new IllegalArgumentException("Unsupported method");
        };

        return request.retrieve().body(responseType);
    }
}


ä¸šåŠ¡ä»£ç å°±å˜æˆé…ç½®é©±åŠ¨çš„ï¼š

public CustomerInfo getCustomerById(String customerId) {
    return invoker.invoke("customer", "get-customer",
            Map.of("id", customerId), null, CustomerInfo.class);
}


ä¼˜ç‚¹ï¼š

API è§„èŒƒé›†ä¸­åœ¨é…ç½®ï¼Œä¸æ•£è½åœ¨ä»£ç ï¼›

æ–°å¢å¤–éƒ¨æ¥å£åªéœ€è¦æ”¹é…ç½®ï¼Œä¸ç”¨æ”¹ Java ç±»ï¼›

çµæ´»åº¦é«˜ï¼Œæ”¯æŒä¸åŒæ–¹æ³•ã€è·¯å¾„ã€è¿”å›ç±»å‹ã€‚

æ–¹æ¡ˆ B: å€ŸåŠ© Feign (å¦‚æœèƒ½æ¥å—ä¾èµ–)

Spring Cloud OpenFeign æœ¬èº«å°±èƒ½é€šè¿‡æ¥å£å£°æ˜å¼è°ƒç”¨ + æ‹¦æˆªå™¨é“¾å®ç°ï¼›ä½†ç¼ºç‚¹æ˜¯ä¼šå¸¦æ¥ä¾èµ–å’Œé¢å¤–ä»£ç†é€»è¾‘ã€‚
å¦‚æœä½ é¡¹ç›®è¦æ±‚ é¢†åŸŸå±‚ä¸ä¾èµ–æ¡†æ¶ï¼Œå»ºè®®è¿˜æ˜¯èµ° æ–¹æ¡ˆ Aã€‚

ğŸ¯ æ€»ç»“

é…ç½®åŒ–å¼€å…³ï¼šæ”¯æŒç³»ç»Ÿçº§åˆ«æ§åˆ¶æ˜¯å¦è®°å½•å“åº”ä½“ã€æˆªæ–­å¤§å°ï¼›

å“åº”ä½“é‡å¤è¯»ï¼šæ¨èå…¨å±€å¯ç”¨ BufferingClientHttpRequestFactoryï¼›

ä¼˜é›…æ¥å£è°ƒç”¨ï¼šé€šè¿‡é…ç½®åŒ– API å®šä¹‰ + é€šç”¨ DynamicApiInvokerï¼Œé¿å…æ¥å£è°ƒç”¨æ•£è½åœ¨ä»£ç ä¸­ã€‚

è¦ä¸è¦æˆ‘å¸®ä½ æŠŠ æ–¹æ¡ˆ Aï¼ˆé…ç½®é©±åŠ¨è°ƒç”¨å™¨ï¼‰ å®Œæ•´å±•å¼€æˆä¸€ä¸ª mini æ¡†æ¶ï¼ŒåŒ…æ‹¬é…ç½®ç±»ã€Invokerã€ç¤ºä¾‹é…ç½®å’Œä¸šåŠ¡è°ƒç”¨ç¤ºä¾‹ï¼Ÿè¿™æ ·ä½ å°±å¯ä»¥ç›´æ¥æ‹¿æ¥åœ¨é¡¹ç›®é‡Œè½åœ°ã€‚

æ‚¨è¯´ï¼š
1. æˆ‘ä»¬è®¾è®¡ä¸€ä¸ªRestClientFactoryï¼Œç”¨æ¥åˆ›å»ºRestClientï¼Œè¿™ä¸ªRestClientFactoryé‡Œé¢ä¼šæ³¨å…¥é¢„å…ˆå®šä¹‰å¥½çš„å…¬å…±æ‹¦æˆªå™¨ï¼Œä¾‹å¦‚å®¡è®¡æ—¥å¿—è®°å½•ã€å¯è§‚æµ‹æ•°æ®ç»Ÿè®¡ç­‰

2. æ¯ä¸ªå¤–éƒ¨ç³»ç»Ÿä¼šåˆ›å»ºä¸€ä¸ªRestClientå®ä¾‹ï¼Œåˆ›å»ºçš„æ—¶å€™ä¼šå°†è¿™ä¸ªç³»ç»Ÿæ¥å£çš„å…¬å…±è¦æ±‚æ”¾è¿›å»ï¼Œå¦‚base-urlï¼Œè¶…æ—¶æ—¶é—´ç­‰ï¼ŒRestClientFactoryåˆ›å»ºRestClientçš„æ—¶å€™ï¼Œéœ€è¦ä¼ å…¥ä¸€ä¸ªSystemConfigç±»å‹çš„å‚æ•°ï¼Œç”¨æ¥ä¼ å…¥è¿™äº›å…¬å…±å‚æ•°

3. åœ¨å¤–éƒ¨ç³»ç»Ÿå±‚é¢ï¼Œè¿˜éœ€è¦å®šä¹‰è¯¥ç³»ç»Ÿå…¬ç”¨çš„è¯·æ±‚å¤´ã€è¿”å›å¤´

4. å…·ä½“åˆ°æ¥å£å±‚é¢ï¼Œåœ¨è¯·æ±‚ä½“å’Œè¿”å›ä½“ä¸Šæ ‡æ³¨ä»–ä»¬å±äºå“ªä¸ªç³»ç»Ÿçš„å“ªä¸ªæ¥å£

5. åœ¨javaä¸­å®šä¹‰æ¯ä¸ªç³»ç»Ÿçš„æ¥å£åç§°åˆ—è¡¨æ—¶ï¼Œé€šè¿‡æ³¨è§£æŒ‡å®šä»–ä»¬çš„uri,è¯·æ±‚æ–¹å¼

6.åœ¨å‘èµ·å¤–éƒ¨è°ƒç”¨è¯·æ±‚çš„æ—¶å€™ï¼Œè°ƒç”¨è¯¥ç³»ç»Ÿçš„æ¥å£æœåŠ¡ï¼Œä¼ å…¥æ¥å£åç§°å’Œè¯·æ±‚ä½“ï¼Œå®¢æˆ·ç«¯é€šè¿‡ç³»ç»Ÿå’Œæ¥å£åç§°ï¼Œæ‰¾åˆ°å¯¹åº”çš„uri,è¯·æ±‚æ–¹å¼å’Œè¿”å›ä½“ï¼Œå®Œæˆè°ƒç”¨
ChatGPT è¯´ï¼š

å¾ˆå¥½ ğŸ‘ ä½ å·²ç»æŠŠéœ€æ±‚æ‹†å¾—å¾ˆæ¸…æ™°äº†ã€‚ä½ çš„æ€è·¯å…¶å®å°±æ˜¯è¦åœ¨ ç³»ç»Ÿå±‚ï¼ˆSystemConfigï¼‰ å’Œ æ¥å£å±‚ï¼ˆAPI å…ƒæ•°æ®ï¼‰ ä¸¤ä¸ªç»´åº¦æŠŠé…ç½®æŠ½è±¡å‡ºæ¥ï¼Œå†é€šè¿‡ RestClientFactory + å…ƒæ•°æ®è§£æ å®Œæˆè¯·æ±‚çš„åŠ¨æ€æ„é€ å’Œç»Ÿä¸€æ‹¦æˆªå™¨æŒ‚è½½ã€‚

æˆ‘æ¥å¸®ä½ æ•´ç†æˆä¸€ä¸ªå®Œæ•´çš„æ¶æ„æ–¹æ¡ˆï¼š

ğŸ”¹ 1. RestClientFactory

è´Ÿè´£åˆ›å»ºå¸¦æœ‰å…¬å…±æ‹¦æˆªå™¨çš„ RestClient å®ä¾‹ï¼Œä¿è¯ æ‰€æœ‰å¤–éƒ¨è°ƒç”¨å…·å¤‡ç»Ÿä¸€çš„å¯è§‚æµ‹æ€§å’Œå®¡è®¡èƒ½åŠ›ã€‚

@Component
@RequiredArgsConstructor
public class RestClientFactory {

    private final List<ClientHttpRequestInterceptor> globalInterceptors;

    public RestClient create(SystemConfig config) {
        RestTemplate restTemplate = new RestTemplateBuilder()
                .requestFactory(() ->
                    new BufferingClientHttpRequestFactory(new SimpleClientHttpRequestFactory()))
                .setConnectTimeout(config.getConnectTimeout())
                .setReadTimeout(config.getReadTimeout())
                .additionalInterceptors(globalInterceptors)
                .build();

        return RestClient.builder()
                .baseUrl(config.getBaseUrl())
                .requestFactory(restTemplate.getRequestFactory())
                .build();
    }
}


ğŸ‘‰ å…¨å±€æ‹¦æˆªå™¨åŒ…æ‹¬ï¼š

AuditInterceptorï¼ˆè®°å½•è¯·æ±‚/å“åº”ï¼Œè„±æ•ï¼Œæˆªæ–­ï¼‰

MetricsInterceptorï¼ˆè€—æ—¶ç»Ÿè®¡ã€çŠ¶æ€ç è®¡æ•°ï¼‰

ExceptionInterceptorï¼ˆç»Ÿä¸€å¼‚å¸¸æ˜ å°„ï¼‰

ğŸ”¹ 2. SystemConfig

å®šä¹‰æ¯ä¸ªå¤–éƒ¨ç³»ç»Ÿçš„å…¬å…±é…ç½®ã€‚

@Data
@Builder
public class SystemConfig {
    private String systemCode;
    private String baseUrl;
    private Duration connectTimeout;
    private Duration readTimeout;
    private Map<String, String> defaultHeaders;
}

ğŸ”¹ 3. API å…ƒæ•°æ®ï¼ˆæ¥å£å®šä¹‰å±‚ï¼‰

é€šè¿‡ æ³¨è§£ æˆ– é…ç½®æ–‡ä»¶ æ¥å®šä¹‰æ¥å£åˆ—è¡¨ï¼Œè€Œä¸æ˜¯åœ¨ä»£ç ä¸­å†™æ­»ã€‚

æ–¹å¼ Aï¼šæ³¨è§£
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiMapping {
    String name();      // æ¥å£åç§°ï¼Œå¦‚ "getCustomerById"
    String uri();       // URI æ¨¡æ¿
    HttpMethod method();// GET/POST/PUT/DELETE
    Class<?> response(); // è¿”å›ä½“ç±»å‹
}


æ¥å£å®šä¹‰ï¼š

public interface CustomerApi {

    @ApiMapping(
        name = "getCustomerById",
        uri = "/api/customers/{id}",
        method = HttpMethod.GET,
        response = CustomerInfo.class
    )
    CustomerInfo getCustomerById(String id);

    @ApiMapping(
        name = "searchCustomers",
        uri = "/api/customers/search",
        method = HttpMethod.POST,
        response = List.class
    )
    List<CustomerInfo> searchCustomers(CustomerSearchRequest req);
}

æ–¹å¼ Bï¼šé…ç½®æ–‡ä»¶ï¼ˆæ¨èç»™è¿ç»´/åŠ¨æ€æ›´æ–°ï¼‰
systems:
  customer-system:
    base-url: https://customer.example.com
    apis:
      - name: getCustomerById
        uri: /api/customers/{id}
        method: GET
        response: com.example.CustomerInfo
      - name: searchCustomers
        uri: /api/customers/search
        method: POST
        response: java.util.List

ğŸ”¹ 4. API å…ƒæ•°æ®æ³¨å†Œä¸­å¿ƒ

æŠŠæ³¨è§£æˆ– YAML é…ç½®è§£æä¸º ApiDefinitionï¼Œæ”¾åˆ°æ³¨å†Œä¸­å¿ƒé‡Œã€‚

@Data
@Builder
public class ApiDefinition {
    private String name;
    private String uri;
    private HttpMethod method;
    private Class<?> responseType;
}


æ³¨å†Œä¸­å¿ƒï¼š

@Component
public class ApiRegistry {

    private final Map<String, Map<String, ApiDefinition>> registry = new HashMap<>();

    public void register(String systemCode, List<ApiDefinition> apis) {
        registry.put(systemCode, apis.stream()
            .collect(Collectors.toMap(ApiDefinition::getName, a -> a)));
    }

    public ApiDefinition get(String systemCode, String apiName) {
        return registry.getOrDefault(systemCode, Map.of()).get(apiName);
    }
}

ğŸ”¹ 5. é€šç”¨å®¢æˆ·ç«¯è°ƒç”¨å…¥å£

å¼€å‘è€…åªéœ€è¦ä¼ å…¥ç³»ç»Ÿå’Œ API åç§°ï¼Œ+ è¯·æ±‚å‚æ•°ï¼Œå°±èƒ½è‡ªåŠ¨æ‰¾åˆ°å…ƒæ•°æ®å‘èµ·è°ƒç”¨ã€‚

@Component
@RequiredArgsConstructor
public class ExternalApiClient {

    private final RestClientFactory factory;
    private final ApiRegistry apiRegistry;
    private final Map<String, RestClient> clientCache = new ConcurrentHashMap<>();

    public <T> T call(String systemCode, String apiName, Object request, Object... uriVars) {
        SystemConfig config = loadSystemConfig(systemCode);
        RestClient client = clientCache.computeIfAbsent(systemCode, k -> factory.create(config));

        ApiDefinition api = apiRegistry.get(systemCode, apiName);

        return client.method(api.getMethod())
                .uri(api.getUri(), uriVars)
                .headers(h -> config.getDefaultHeaders().forEach(h::add))
                .body(request)
                .retrieve()
                .body(api.getResponseType());
    }

    private SystemConfig loadSystemConfig(String systemCode) {
        // ä»é…ç½®ä¸­å¿ƒæˆ–æ•°æ®åº“è·å–
        return ...;
    }
}

ğŸ”¹ 6. é…ç½®åŒ–å¼€å…³

å¯ä»¥é€šè¿‡é…ç½®æ§åˆ¶ æ˜¯å¦è®°å½•å“åº”ä½“ / æˆªæ–­å¤§å° / è„±æ•è§„åˆ™ï¼š

audit:
  enabled-systems: [customer-system, order-system]
  max-body-size: 2048
  sensitive-fields:
    - token
    - idCard


AuditInterceptor åœ¨æ‰§è¡Œæ—¶è¯»å–é…ç½®ï¼ŒåŠ¨æ€å†³å®šæ˜¯å¦è®°å½• bodyï¼Œæ˜¯å¦æˆªæ–­ã€‚

âœ… æ€»ç»“

è¿™æ ·è®¾è®¡åï¼Œä½ èƒ½åšåˆ°ï¼š

ç»Ÿä¸€æ‹¦æˆªå™¨ï¼šæ—¥å¿—ã€ç›‘æ§ã€å¼‚å¸¸å¤„ç†åªå†™ä¸€æ¬¡ï¼Œæ‰€æœ‰ç³»ç»Ÿ client è‡ªåŠ¨æŒ‚è½½ã€‚

é…ç½®é©±åŠ¨æ¥å£è°ƒç”¨ï¼šæ¥å£å…ƒæ•°æ®ä¸å†å†™æ­»åœ¨ä»£ç ï¼Œæ”¯æŒæ³¨è§£ + YAML åŒæ¨¡å¼ã€‚

çµæ´»çš„å®¡è®¡ä¸ç›‘æ§ï¼šæ”¯æŒåŠ¨æ€å¼€å…³ã€body æˆªæ–­ã€æ•æ„Ÿå­—æ®µè„±æ•ã€‚

ä»£ç å¤ç”¨åº¦é«˜ï¼šæ–°å¢ä¸€ä¸ªå¤–éƒ¨ç³»ç»Ÿï¼Œåªéœ€é…å¥½ SystemConfig + ApiDefinitionï¼Œä¸éœ€è¦å†å†™ N å¤š getCustomerById æ–¹æ³•ã€‚

è¦ä¸è¦æˆ‘å¸®ä½ å†™ä¸€ä¸ª å®Œæ•´ç¤ºä¾‹ï¼ˆå«æ‹¦æˆªå™¨é“¾ + å®¡è®¡é…ç½®å¼€å…³ + æ³¨è§£è§£æå™¨ï¼‰ çš„å¯è¿è¡Œ demo ä»£ç ï¼ˆSpring Boot é¡¹ç›®éª¨æ¶ï¼‰ï¼Ÿ
